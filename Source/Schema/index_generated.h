// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_INDEX_H_
#define FLATBUFFERS_GENERATED_INDEX_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

struct FloatVector;

struct DoubleVector;

struct Transform;

struct Material;

struct BoundingBox;

struct Wire;

struct WireSet;
struct WireSetBuilder;

struct CircleCurve;

struct ShellHole;
struct ShellHoleBuilder;

struct ShellProfile;
struct ShellProfileBuilder;

struct Axis;
struct AxisBuilder;

struct Representation;

struct Sample;

struct Shell;
struct ShellBuilder;

struct CircleExtrusion;
struct CircleExtrusionBuilder;

struct Meshes;
struct MeshesBuilder;

struct Attribute;
struct AttributeBuilder;

struct Relation;
struct RelationBuilder;

struct SpatialStructure;
struct SpatialStructureBuilder;

struct Alignment;
struct AlignmentBuilder;

struct GeometrySample;

struct GeometryLines;
struct GeometryLinesBuilder;

struct Geometries;
struct GeometriesBuilder;

struct Model;
struct ModelBuilder;

enum RenderedFaces : int8_t {
  RenderedFaces_ONE = 0,
  RenderedFaces_TWO = 1,
  RenderedFaces_MIN = RenderedFaces_ONE,
  RenderedFaces_MAX = RenderedFaces_TWO
};

inline const RenderedFaces (&EnumValuesRenderedFaces())[2] {
  static const RenderedFaces values[] = {
    RenderedFaces_ONE,
    RenderedFaces_TWO
  };
  return values;
}

inline const char * const *EnumNamesRenderedFaces() {
  static const char * const names[3] = {
    "ONE",
    "TWO",
    nullptr
  };
  return names;
}

inline const char *EnumNameRenderedFaces(RenderedFaces e) {
  if (::flatbuffers::IsOutRange(e, RenderedFaces_ONE, RenderedFaces_TWO)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRenderedFaces()[index];
}

enum Stroke : int8_t {
  Stroke_DEFAULT = 0,
  Stroke_MIN = Stroke_DEFAULT,
  Stroke_MAX = Stroke_DEFAULT
};

inline const Stroke (&EnumValuesStroke())[1] {
  static const Stroke values[] = {
    Stroke_DEFAULT
  };
  return values;
}

inline const char * const *EnumNamesStroke() {
  static const char * const names[2] = {
    "DEFAULT",
    nullptr
  };
  return names;
}

inline const char *EnumNameStroke(Stroke e) {
  if (::flatbuffers::IsOutRange(e, Stroke_DEFAULT, Stroke_DEFAULT)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStroke()[index];
}

enum AxisPartClass : int8_t {
  AxisPartClass_NONE = 0,
  AxisPartClass_WIRE = 1,
  AxisPartClass_WIRE_SET = 2,
  AxisPartClass_CIRCLE_CURVE = 3,
  AxisPartClass_MIN = AxisPartClass_NONE,
  AxisPartClass_MAX = AxisPartClass_CIRCLE_CURVE
};

inline const AxisPartClass (&EnumValuesAxisPartClass())[4] {
  static const AxisPartClass values[] = {
    AxisPartClass_NONE,
    AxisPartClass_WIRE,
    AxisPartClass_WIRE_SET,
    AxisPartClass_CIRCLE_CURVE
  };
  return values;
}

inline const char * const *EnumNamesAxisPartClass() {
  static const char * const names[5] = {
    "NONE",
    "WIRE",
    "WIRE_SET",
    "CIRCLE_CURVE",
    nullptr
  };
  return names;
}

inline const char *EnumNameAxisPartClass(AxisPartClass e) {
  if (::flatbuffers::IsOutRange(e, AxisPartClass_NONE, AxisPartClass_CIRCLE_CURVE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAxisPartClass()[index];
}

enum RepresentationClass : int8_t {
  RepresentationClass_NONE = 0,
  RepresentationClass_SHELL = 1,
  RepresentationClass_CIRCLE_EXTRUSION = 2,
  RepresentationClass_MIN = RepresentationClass_NONE,
  RepresentationClass_MAX = RepresentationClass_CIRCLE_EXTRUSION
};

inline const RepresentationClass (&EnumValuesRepresentationClass())[3] {
  static const RepresentationClass values[] = {
    RepresentationClass_NONE,
    RepresentationClass_SHELL,
    RepresentationClass_CIRCLE_EXTRUSION
  };
  return values;
}

inline const char * const *EnumNamesRepresentationClass() {
  static const char * const names[4] = {
    "NONE",
    "SHELL",
    "CIRCLE_EXTRUSION",
    nullptr
  };
  return names;
}

inline const char *EnumNameRepresentationClass(RepresentationClass e) {
  if (::flatbuffers::IsOutRange(e, RepresentationClass_NONE, RepresentationClass_CIRCLE_EXTRUSION)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRepresentationClass()[index];
}

enum GeometryClass : int8_t {
  GeometryClass_NONE = 0,
  GeometryClass_LINES = 1,
  GeometryClass_ELLIPSE_ARC = 2,
  GeometryClass_CLOTHOID = 3,
  GeometryClass_PARABOLA = 4,
  GeometryClass_MIN = GeometryClass_NONE,
  GeometryClass_MAX = GeometryClass_PARABOLA
};

inline const GeometryClass (&EnumValuesGeometryClass())[5] {
  static const GeometryClass values[] = {
    GeometryClass_NONE,
    GeometryClass_LINES,
    GeometryClass_ELLIPSE_ARC,
    GeometryClass_CLOTHOID,
    GeometryClass_PARABOLA
  };
  return values;
}

inline const char * const *EnumNamesGeometryClass() {
  static const char * const names[6] = {
    "NONE",
    "LINES",
    "ELLIPSE_ARC",
    "CLOTHOID",
    "PARABOLA",
    nullptr
  };
  return names;
}

inline const char *EnumNameGeometryClass(GeometryClass e) {
  if (::flatbuffers::IsOutRange(e, GeometryClass_NONE, GeometryClass_PARABOLA)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesGeometryClass()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) FloatVector FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  FloatVector()
      : x_(0),
        y_(0),
        z_(0) {
  }
  FloatVector(float _x, float _y, float _z)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)),
        z_(::flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return ::flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(FloatVector, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) DoubleVector FLATBUFFERS_FINAL_CLASS {
 private:
  double x_;
  double y_;
  double z_;

 public:
  DoubleVector()
      : x_(0),
        y_(0),
        z_(0) {
  }
  DoubleVector(double _x, double _y, double _z)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)),
        z_(::flatbuffers::EndianScalar(_z)) {
  }
  double x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  double y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
  double z() const {
    return ::flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(DoubleVector, 24);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) Transform FLATBUFFERS_FINAL_CLASS {
 private:
  DoubleVector position_;
  FloatVector x_direction_;
  FloatVector y_direction_;

 public:
  Transform()
      : position_(),
        x_direction_(),
        y_direction_() {
  }
  Transform(const DoubleVector &_position, const FloatVector &_x_direction, const FloatVector &_y_direction)
      : position_(_position),
        x_direction_(_x_direction),
        y_direction_(_y_direction) {
  }
  const DoubleVector &position() const {
    return position_;
  }
  const FloatVector &x_direction() const {
    return x_direction_;
  }
  const FloatVector &y_direction() const {
    return y_direction_;
  }
};
FLATBUFFERS_STRUCT_END(Transform, 48);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) Material FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t r_;
  uint8_t g_;
  uint8_t b_;
  uint8_t a_;
  int8_t rendered_faces_;
  int8_t stroke_;

 public:
  Material()
      : r_(0),
        g_(0),
        b_(0),
        a_(0),
        rendered_faces_(0),
        stroke_(0) {
  }
  Material(uint8_t _r, uint8_t _g, uint8_t _b, uint8_t _a, RenderedFaces _rendered_faces, Stroke _stroke)
      : r_(::flatbuffers::EndianScalar(_r)),
        g_(::flatbuffers::EndianScalar(_g)),
        b_(::flatbuffers::EndianScalar(_b)),
        a_(::flatbuffers::EndianScalar(_a)),
        rendered_faces_(::flatbuffers::EndianScalar(static_cast<int8_t>(_rendered_faces))),
        stroke_(::flatbuffers::EndianScalar(static_cast<int8_t>(_stroke))) {
  }
  uint8_t r() const {
    return ::flatbuffers::EndianScalar(r_);
  }
  uint8_t g() const {
    return ::flatbuffers::EndianScalar(g_);
  }
  uint8_t b() const {
    return ::flatbuffers::EndianScalar(b_);
  }
  uint8_t a() const {
    return ::flatbuffers::EndianScalar(a_);
  }
  RenderedFaces rendered_faces() const {
    return static_cast<RenderedFaces>(::flatbuffers::EndianScalar(rendered_faces_));
  }
  Stroke stroke() const {
    return static_cast<Stroke>(::flatbuffers::EndianScalar(stroke_));
  }
};
FLATBUFFERS_STRUCT_END(Material, 6);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) BoundingBox FLATBUFFERS_FINAL_CLASS {
 private:
  FloatVector min_;
  FloatVector max_;

 public:
  BoundingBox()
      : min_(),
        max_() {
  }
  BoundingBox(const FloatVector &_min, const FloatVector &_max)
      : min_(_min),
        max_(_max) {
  }
  const FloatVector &min() const {
    return min_;
  }
  const FloatVector &max() const {
    return max_;
  }
};
FLATBUFFERS_STRUCT_END(BoundingBox, 24);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Wire FLATBUFFERS_FINAL_CLASS {
 private:
  FloatVector p1_;
  FloatVector p2_;

 public:
  Wire()
      : p1_(),
        p2_() {
  }
  Wire(const FloatVector &_p1, const FloatVector &_p2)
      : p1_(_p1),
        p2_(_p2) {
  }
  const FloatVector &p1() const {
    return p1_;
  }
  const FloatVector &p2() const {
    return p2_;
  }
};
FLATBUFFERS_STRUCT_END(Wire, 24);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) CircleCurve FLATBUFFERS_FINAL_CLASS {
 private:
  float aperture_;
  FloatVector position_;
  float radius_;
  FloatVector x_direction_;
  FloatVector y_direction_;

 public:
  CircleCurve()
      : aperture_(0),
        position_(),
        radius_(0),
        x_direction_(),
        y_direction_() {
  }
  CircleCurve(float _aperture, const FloatVector &_position, float _radius, const FloatVector &_x_direction, const FloatVector &_y_direction)
      : aperture_(::flatbuffers::EndianScalar(_aperture)),
        position_(_position),
        radius_(::flatbuffers::EndianScalar(_radius)),
        x_direction_(_x_direction),
        y_direction_(_y_direction) {
  }
  float aperture() const {
    return ::flatbuffers::EndianScalar(aperture_);
  }
  const FloatVector &position() const {
    return position_;
  }
  float radius() const {
    return ::flatbuffers::EndianScalar(radius_);
  }
  const FloatVector &x_direction() const {
    return x_direction_;
  }
  const FloatVector &y_direction() const {
    return y_direction_;
  }
};
FLATBUFFERS_STRUCT_END(CircleCurve, 44);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Representation FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t id_;
  BoundingBox bbox_;
  int8_t representation_class_;
  int8_t padding0__;  int16_t padding1__;

 public:
  Representation()
      : id_(0),
        bbox_(),
        representation_class_(0),
        padding0__(0),
        padding1__(0) {
    (void)padding0__;
    (void)padding1__;
  }
  Representation(uint32_t _id, const BoundingBox &_bbox, RepresentationClass _representation_class)
      : id_(::flatbuffers::EndianScalar(_id)),
        bbox_(_bbox),
        representation_class_(::flatbuffers::EndianScalar(static_cast<int8_t>(_representation_class))),
        padding0__(0),
        padding1__(0) {
    (void)padding0__;
    (void)padding1__;
  }
  uint32_t id() const {
    return ::flatbuffers::EndianScalar(id_);
  }
  const BoundingBox &bbox() const {
    return bbox_;
  }
  RepresentationClass representation_class() const {
    return static_cast<RepresentationClass>(::flatbuffers::EndianScalar(representation_class_));
  }
};
FLATBUFFERS_STRUCT_END(Representation, 32);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Sample FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t item_;
  uint32_t material_;
  uint32_t representation_;
  uint32_t local_transform_;

 public:
  Sample()
      : item_(0),
        material_(0),
        representation_(0),
        local_transform_(0) {
  }
  Sample(uint32_t _item, uint32_t _material, uint32_t _representation, uint32_t _local_transform)
      : item_(::flatbuffers::EndianScalar(_item)),
        material_(::flatbuffers::EndianScalar(_material)),
        representation_(::flatbuffers::EndianScalar(_representation)),
        local_transform_(::flatbuffers::EndianScalar(_local_transform)) {
  }
  uint32_t item() const {
    return ::flatbuffers::EndianScalar(item_);
  }
  uint32_t material() const {
    return ::flatbuffers::EndianScalar(material_);
  }
  uint32_t representation() const {
    return ::flatbuffers::EndianScalar(representation_);
  }
  uint32_t local_transform() const {
    return ::flatbuffers::EndianScalar(local_transform_);
  }
};
FLATBUFFERS_STRUCT_END(Sample, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) GeometrySample FLATBUFFERS_FINAL_CLASS {
 private:
  int8_t geometry_class_;
  int8_t padding0__;  int16_t padding1__;
  uint32_t id_;
  uint32_t transform_;

 public:
  GeometrySample()
      : geometry_class_(0),
        padding0__(0),
        padding1__(0),
        id_(0),
        transform_(0) {
    (void)padding0__;
    (void)padding1__;
  }
  GeometrySample(GeometryClass _geometry_class, uint32_t _id, uint32_t _transform)
      : geometry_class_(::flatbuffers::EndianScalar(static_cast<int8_t>(_geometry_class))),
        padding0__(0),
        padding1__(0),
        id_(::flatbuffers::EndianScalar(_id)),
        transform_(::flatbuffers::EndianScalar(_transform)) {
    (void)padding0__;
    (void)padding1__;
  }
  GeometryClass geometry_class() const {
    return static_cast<GeometryClass>(::flatbuffers::EndianScalar(geometry_class_));
  }
  uint32_t id() const {
    return ::flatbuffers::EndianScalar(id_);
  }
  uint32_t transform() const {
    return ::flatbuffers::EndianScalar(transform_);
  }
};
FLATBUFFERS_STRUCT_END(GeometrySample, 12);

struct WireSet FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WireSetBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PS = 4
  };
  const ::flatbuffers::Vector<const FloatVector *> *ps() const {
    return GetPointer<const ::flatbuffers::Vector<const FloatVector *> *>(VT_PS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PS) &&
           verifier.VerifyVector(ps()) &&
           verifier.EndTable();
  }
};

struct WireSetBuilder {
  typedef WireSet Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ps(::flatbuffers::Offset<::flatbuffers::Vector<const FloatVector *>> ps) {
    fbb_.AddOffset(WireSet::VT_PS, ps);
  }
  explicit WireSetBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<WireSet> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<WireSet>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<WireSet> CreateWireSet(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<const FloatVector *>> ps = 0) {
  WireSetBuilder builder_(_fbb);
  builder_.add_ps(ps);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<WireSet> CreateWireSetDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<FloatVector> *ps = nullptr) {
  auto ps__ = ps ? _fbb.CreateVectorOfStructs<FloatVector>(*ps) : 0;
  return CreateWireSet(
      _fbb,
      ps__);
}

struct ShellHole FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ShellHoleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INDICES = 4,
    VT_PROFILE_ID = 6
  };
  const ::flatbuffers::Vector<uint16_t> *indices() const {
    return GetPointer<const ::flatbuffers::Vector<uint16_t> *>(VT_INDICES);
  }
  uint16_t profile_id() const {
    return GetField<uint16_t>(VT_PROFILE_ID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_INDICES) &&
           verifier.VerifyVector(indices()) &&
           VerifyField<uint16_t>(verifier, VT_PROFILE_ID, 2) &&
           verifier.EndTable();
  }
};

struct ShellHoleBuilder {
  typedef ShellHole Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_indices(::flatbuffers::Offset<::flatbuffers::Vector<uint16_t>> indices) {
    fbb_.AddOffset(ShellHole::VT_INDICES, indices);
  }
  void add_profile_id(uint16_t profile_id) {
    fbb_.AddElement<uint16_t>(ShellHole::VT_PROFILE_ID, profile_id, 0);
  }
  explicit ShellHoleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ShellHole> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ShellHole>(end);
    fbb_.Required(o, ShellHole::VT_INDICES);
    return o;
  }
};

inline ::flatbuffers::Offset<ShellHole> CreateShellHole(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint16_t>> indices = 0,
    uint16_t profile_id = 0) {
  ShellHoleBuilder builder_(_fbb);
  builder_.add_indices(indices);
  builder_.add_profile_id(profile_id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ShellHole> CreateShellHoleDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint16_t> *indices = nullptr,
    uint16_t profile_id = 0) {
  auto indices__ = indices ? _fbb.CreateVector<uint16_t>(*indices) : 0;
  return CreateShellHole(
      _fbb,
      indices__,
      profile_id);
}

struct ShellProfile FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ShellProfileBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INDICES = 4
  };
  const ::flatbuffers::Vector<uint16_t> *indices() const {
    return GetPointer<const ::flatbuffers::Vector<uint16_t> *>(VT_INDICES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_INDICES) &&
           verifier.VerifyVector(indices()) &&
           verifier.EndTable();
  }
};

struct ShellProfileBuilder {
  typedef ShellProfile Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_indices(::flatbuffers::Offset<::flatbuffers::Vector<uint16_t>> indices) {
    fbb_.AddOffset(ShellProfile::VT_INDICES, indices);
  }
  explicit ShellProfileBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ShellProfile> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ShellProfile>(end);
    fbb_.Required(o, ShellProfile::VT_INDICES);
    return o;
  }
};

inline ::flatbuffers::Offset<ShellProfile> CreateShellProfile(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint16_t>> indices = 0) {
  ShellProfileBuilder builder_(_fbb);
  builder_.add_indices(indices);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ShellProfile> CreateShellProfileDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint16_t> *indices = nullptr) {
  auto indices__ = indices ? _fbb.CreateVector<uint16_t>(*indices) : 0;
  return CreateShellProfile(
      _fbb,
      indices__);
}

struct Axis FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AxisBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WIRES = 4,
    VT_ORDER = 6,
    VT_PARTS = 8,
    VT_WIRE_SETS = 10,
    VT_CIRCLE_CURVES = 12
  };
  const ::flatbuffers::Vector<const Wire *> *wires() const {
    return GetPointer<const ::flatbuffers::Vector<const Wire *> *>(VT_WIRES);
  }
  const ::flatbuffers::Vector<uint32_t> *order() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_ORDER);
  }
  const ::flatbuffers::Vector<int8_t> *parts() const {
    return GetPointer<const ::flatbuffers::Vector<int8_t> *>(VT_PARTS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<WireSet>> *wire_sets() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<WireSet>> *>(VT_WIRE_SETS);
  }
  const ::flatbuffers::Vector<const CircleCurve *> *circle_curves() const {
    return GetPointer<const ::flatbuffers::Vector<const CircleCurve *> *>(VT_CIRCLE_CURVES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_WIRES) &&
           verifier.VerifyVector(wires()) &&
           VerifyOffsetRequired(verifier, VT_ORDER) &&
           verifier.VerifyVector(order()) &&
           VerifyOffsetRequired(verifier, VT_PARTS) &&
           verifier.VerifyVector(parts()) &&
           VerifyOffsetRequired(verifier, VT_WIRE_SETS) &&
           verifier.VerifyVector(wire_sets()) &&
           verifier.VerifyVectorOfTables(wire_sets()) &&
           VerifyOffsetRequired(verifier, VT_CIRCLE_CURVES) &&
           verifier.VerifyVector(circle_curves()) &&
           verifier.EndTable();
  }
};

struct AxisBuilder {
  typedef Axis Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_wires(::flatbuffers::Offset<::flatbuffers::Vector<const Wire *>> wires) {
    fbb_.AddOffset(Axis::VT_WIRES, wires);
  }
  void add_order(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> order) {
    fbb_.AddOffset(Axis::VT_ORDER, order);
  }
  void add_parts(::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> parts) {
    fbb_.AddOffset(Axis::VT_PARTS, parts);
  }
  void add_wire_sets(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<WireSet>>> wire_sets) {
    fbb_.AddOffset(Axis::VT_WIRE_SETS, wire_sets);
  }
  void add_circle_curves(::flatbuffers::Offset<::flatbuffers::Vector<const CircleCurve *>> circle_curves) {
    fbb_.AddOffset(Axis::VT_CIRCLE_CURVES, circle_curves);
  }
  explicit AxisBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Axis> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Axis>(end);
    fbb_.Required(o, Axis::VT_WIRES);
    fbb_.Required(o, Axis::VT_ORDER);
    fbb_.Required(o, Axis::VT_PARTS);
    fbb_.Required(o, Axis::VT_WIRE_SETS);
    fbb_.Required(o, Axis::VT_CIRCLE_CURVES);
    return o;
  }
};

inline ::flatbuffers::Offset<Axis> CreateAxis(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<const Wire *>> wires = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> order = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> parts = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<WireSet>>> wire_sets = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const CircleCurve *>> circle_curves = 0) {
  AxisBuilder builder_(_fbb);
  builder_.add_circle_curves(circle_curves);
  builder_.add_wire_sets(wire_sets);
  builder_.add_parts(parts);
  builder_.add_order(order);
  builder_.add_wires(wires);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Axis> CreateAxisDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<Wire> *wires = nullptr,
    const std::vector<uint32_t> *order = nullptr,
    const std::vector<int8_t> *parts = nullptr,
    const std::vector<::flatbuffers::Offset<WireSet>> *wire_sets = nullptr,
    const std::vector<CircleCurve> *circle_curves = nullptr) {
  auto wires__ = wires ? _fbb.CreateVectorOfStructs<Wire>(*wires) : 0;
  auto order__ = order ? _fbb.CreateVector<uint32_t>(*order) : 0;
  auto parts__ = parts ? _fbb.CreateVector<int8_t>(*parts) : 0;
  auto wire_sets__ = wire_sets ? _fbb.CreateVector<::flatbuffers::Offset<WireSet>>(*wire_sets) : 0;
  auto circle_curves__ = circle_curves ? _fbb.CreateVectorOfStructs<CircleCurve>(*circle_curves) : 0;
  return CreateAxis(
      _fbb,
      wires__,
      order__,
      parts__,
      wire_sets__,
      circle_curves__);
}

struct Shell FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ShellBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PROFILES = 4,
    VT_HOLES = 6,
    VT_POINTS = 8
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<ShellProfile>> *profiles() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ShellProfile>> *>(VT_PROFILES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<ShellHole>> *holes() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ShellHole>> *>(VT_HOLES);
  }
  const ::flatbuffers::Vector<const FloatVector *> *points() const {
    return GetPointer<const ::flatbuffers::Vector<const FloatVector *> *>(VT_POINTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_PROFILES) &&
           verifier.VerifyVector(profiles()) &&
           verifier.VerifyVectorOfTables(profiles()) &&
           VerifyOffsetRequired(verifier, VT_HOLES) &&
           verifier.VerifyVector(holes()) &&
           verifier.VerifyVectorOfTables(holes()) &&
           VerifyOffsetRequired(verifier, VT_POINTS) &&
           verifier.VerifyVector(points()) &&
           verifier.EndTable();
  }
};

struct ShellBuilder {
  typedef Shell Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_profiles(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ShellProfile>>> profiles) {
    fbb_.AddOffset(Shell::VT_PROFILES, profiles);
  }
  void add_holes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ShellHole>>> holes) {
    fbb_.AddOffset(Shell::VT_HOLES, holes);
  }
  void add_points(::flatbuffers::Offset<::flatbuffers::Vector<const FloatVector *>> points) {
    fbb_.AddOffset(Shell::VT_POINTS, points);
  }
  explicit ShellBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Shell> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Shell>(end);
    fbb_.Required(o, Shell::VT_PROFILES);
    fbb_.Required(o, Shell::VT_HOLES);
    fbb_.Required(o, Shell::VT_POINTS);
    return o;
  }
};

inline ::flatbuffers::Offset<Shell> CreateShell(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ShellProfile>>> profiles = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ShellHole>>> holes = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const FloatVector *>> points = 0) {
  ShellBuilder builder_(_fbb);
  builder_.add_points(points);
  builder_.add_holes(holes);
  builder_.add_profiles(profiles);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Shell> CreateShellDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<ShellProfile>> *profiles = nullptr,
    const std::vector<::flatbuffers::Offset<ShellHole>> *holes = nullptr,
    const std::vector<FloatVector> *points = nullptr) {
  auto profiles__ = profiles ? _fbb.CreateVector<::flatbuffers::Offset<ShellProfile>>(*profiles) : 0;
  auto holes__ = holes ? _fbb.CreateVector<::flatbuffers::Offset<ShellHole>>(*holes) : 0;
  auto points__ = points ? _fbb.CreateVectorOfStructs<FloatVector>(*points) : 0;
  return CreateShell(
      _fbb,
      profiles__,
      holes__,
      points__);
}

struct CircleExtrusion FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CircleExtrusionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RADIUS = 4,
    VT_AXES = 6
  };
  const ::flatbuffers::Vector<double> *radius() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_RADIUS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Axis>> *axes() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Axis>> *>(VT_AXES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_RADIUS) &&
           verifier.VerifyVector(radius()) &&
           VerifyOffsetRequired(verifier, VT_AXES) &&
           verifier.VerifyVector(axes()) &&
           verifier.VerifyVectorOfTables(axes()) &&
           verifier.EndTable();
  }
};

struct CircleExtrusionBuilder {
  typedef CircleExtrusion Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_radius(::flatbuffers::Offset<::flatbuffers::Vector<double>> radius) {
    fbb_.AddOffset(CircleExtrusion::VT_RADIUS, radius);
  }
  void add_axes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Axis>>> axes) {
    fbb_.AddOffset(CircleExtrusion::VT_AXES, axes);
  }
  explicit CircleExtrusionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CircleExtrusion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CircleExtrusion>(end);
    fbb_.Required(o, CircleExtrusion::VT_RADIUS);
    fbb_.Required(o, CircleExtrusion::VT_AXES);
    return o;
  }
};

inline ::flatbuffers::Offset<CircleExtrusion> CreateCircleExtrusion(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> radius = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Axis>>> axes = 0) {
  CircleExtrusionBuilder builder_(_fbb);
  builder_.add_axes(axes);
  builder_.add_radius(radius);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CircleExtrusion> CreateCircleExtrusionDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<double> *radius = nullptr,
    const std::vector<::flatbuffers::Offset<Axis>> *axes = nullptr) {
  auto radius__ = radius ? _fbb.CreateVector<double>(*radius) : 0;
  auto axes__ = axes ? _fbb.CreateVector<::flatbuffers::Offset<Axis>>(*axes) : 0;
  return CreateCircleExtrusion(
      _fbb,
      radius__,
      axes__);
}

struct Meshes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MeshesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COORDINATES = 4,
    VT_MESHES_ITEMS = 6,
    VT_SAMPLES = 8,
    VT_REPRESENTATIONS = 10,
    VT_MATERIALS = 12,
    VT_CIRCLE_EXTRUSIONS = 14,
    VT_SHELLS = 16,
    VT_LOCAL_TRANSFORMS = 18,
    VT_GLOBAL_TRANSFORMS = 20
  };
  const Transform *coordinates() const {
    return GetStruct<const Transform *>(VT_COORDINATES);
  }
  const ::flatbuffers::Vector<uint32_t> *meshes_items() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_MESHES_ITEMS);
  }
  const ::flatbuffers::Vector<const Sample *> *samples() const {
    return GetPointer<const ::flatbuffers::Vector<const Sample *> *>(VT_SAMPLES);
  }
  const ::flatbuffers::Vector<const Representation *> *representations() const {
    return GetPointer<const ::flatbuffers::Vector<const Representation *> *>(VT_REPRESENTATIONS);
  }
  const ::flatbuffers::Vector<const Material *> *materials() const {
    return GetPointer<const ::flatbuffers::Vector<const Material *> *>(VT_MATERIALS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<CircleExtrusion>> *circle_extrusions() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<CircleExtrusion>> *>(VT_CIRCLE_EXTRUSIONS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Shell>> *shells() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Shell>> *>(VT_SHELLS);
  }
  const ::flatbuffers::Vector<const Transform *> *local_transforms() const {
    return GetPointer<const ::flatbuffers::Vector<const Transform *> *>(VT_LOCAL_TRANSFORMS);
  }
  const ::flatbuffers::Vector<const Transform *> *global_transforms() const {
    return GetPointer<const ::flatbuffers::Vector<const Transform *> *>(VT_GLOBAL_TRANSFORMS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<Transform>(verifier, VT_COORDINATES, 8) &&
           VerifyOffsetRequired(verifier, VT_MESHES_ITEMS) &&
           verifier.VerifyVector(meshes_items()) &&
           VerifyOffsetRequired(verifier, VT_SAMPLES) &&
           verifier.VerifyVector(samples()) &&
           VerifyOffsetRequired(verifier, VT_REPRESENTATIONS) &&
           verifier.VerifyVector(representations()) &&
           VerifyOffsetRequired(verifier, VT_MATERIALS) &&
           verifier.VerifyVector(materials()) &&
           VerifyOffsetRequired(verifier, VT_CIRCLE_EXTRUSIONS) &&
           verifier.VerifyVector(circle_extrusions()) &&
           verifier.VerifyVectorOfTables(circle_extrusions()) &&
           VerifyOffsetRequired(verifier, VT_SHELLS) &&
           verifier.VerifyVector(shells()) &&
           verifier.VerifyVectorOfTables(shells()) &&
           VerifyOffsetRequired(verifier, VT_LOCAL_TRANSFORMS) &&
           verifier.VerifyVector(local_transforms()) &&
           VerifyOffsetRequired(verifier, VT_GLOBAL_TRANSFORMS) &&
           verifier.VerifyVector(global_transforms()) &&
           verifier.EndTable();
  }
};

struct MeshesBuilder {
  typedef Meshes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_coordinates(const Transform *coordinates) {
    fbb_.AddStruct(Meshes::VT_COORDINATES, coordinates);
  }
  void add_meshes_items(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> meshes_items) {
    fbb_.AddOffset(Meshes::VT_MESHES_ITEMS, meshes_items);
  }
  void add_samples(::flatbuffers::Offset<::flatbuffers::Vector<const Sample *>> samples) {
    fbb_.AddOffset(Meshes::VT_SAMPLES, samples);
  }
  void add_representations(::flatbuffers::Offset<::flatbuffers::Vector<const Representation *>> representations) {
    fbb_.AddOffset(Meshes::VT_REPRESENTATIONS, representations);
  }
  void add_materials(::flatbuffers::Offset<::flatbuffers::Vector<const Material *>> materials) {
    fbb_.AddOffset(Meshes::VT_MATERIALS, materials);
  }
  void add_circle_extrusions(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<CircleExtrusion>>> circle_extrusions) {
    fbb_.AddOffset(Meshes::VT_CIRCLE_EXTRUSIONS, circle_extrusions);
  }
  void add_shells(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Shell>>> shells) {
    fbb_.AddOffset(Meshes::VT_SHELLS, shells);
  }
  void add_local_transforms(::flatbuffers::Offset<::flatbuffers::Vector<const Transform *>> local_transforms) {
    fbb_.AddOffset(Meshes::VT_LOCAL_TRANSFORMS, local_transforms);
  }
  void add_global_transforms(::flatbuffers::Offset<::flatbuffers::Vector<const Transform *>> global_transforms) {
    fbb_.AddOffset(Meshes::VT_GLOBAL_TRANSFORMS, global_transforms);
  }
  explicit MeshesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Meshes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Meshes>(end);
    fbb_.Required(o, Meshes::VT_COORDINATES);
    fbb_.Required(o, Meshes::VT_MESHES_ITEMS);
    fbb_.Required(o, Meshes::VT_SAMPLES);
    fbb_.Required(o, Meshes::VT_REPRESENTATIONS);
    fbb_.Required(o, Meshes::VT_MATERIALS);
    fbb_.Required(o, Meshes::VT_CIRCLE_EXTRUSIONS);
    fbb_.Required(o, Meshes::VT_SHELLS);
    fbb_.Required(o, Meshes::VT_LOCAL_TRANSFORMS);
    fbb_.Required(o, Meshes::VT_GLOBAL_TRANSFORMS);
    return o;
  }
};

inline ::flatbuffers::Offset<Meshes> CreateMeshes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const Transform *coordinates = nullptr,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> meshes_items = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const Sample *>> samples = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const Representation *>> representations = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const Material *>> materials = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<CircleExtrusion>>> circle_extrusions = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Shell>>> shells = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const Transform *>> local_transforms = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const Transform *>> global_transforms = 0) {
  MeshesBuilder builder_(_fbb);
  builder_.add_global_transforms(global_transforms);
  builder_.add_local_transforms(local_transforms);
  builder_.add_shells(shells);
  builder_.add_circle_extrusions(circle_extrusions);
  builder_.add_materials(materials);
  builder_.add_representations(representations);
  builder_.add_samples(samples);
  builder_.add_meshes_items(meshes_items);
  builder_.add_coordinates(coordinates);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Meshes> CreateMeshesDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const Transform *coordinates = nullptr,
    const std::vector<uint32_t> *meshes_items = nullptr,
    const std::vector<Sample> *samples = nullptr,
    const std::vector<Representation> *representations = nullptr,
    const std::vector<Material> *materials = nullptr,
    const std::vector<::flatbuffers::Offset<CircleExtrusion>> *circle_extrusions = nullptr,
    const std::vector<::flatbuffers::Offset<Shell>> *shells = nullptr,
    const std::vector<Transform> *local_transforms = nullptr,
    const std::vector<Transform> *global_transforms = nullptr) {
  auto meshes_items__ = meshes_items ? _fbb.CreateVector<uint32_t>(*meshes_items) : 0;
  auto samples__ = samples ? _fbb.CreateVectorOfStructs<Sample>(*samples) : 0;
  auto representations__ = representations ? _fbb.CreateVectorOfStructs<Representation>(*representations) : 0;
  auto materials__ = materials ? _fbb.CreateVectorOfStructs<Material>(*materials) : 0;
  auto circle_extrusions__ = circle_extrusions ? _fbb.CreateVector<::flatbuffers::Offset<CircleExtrusion>>(*circle_extrusions) : 0;
  auto shells__ = shells ? _fbb.CreateVector<::flatbuffers::Offset<Shell>>(*shells) : 0;
  auto local_transforms__ = local_transforms ? _fbb.CreateVectorOfStructs<Transform>(*local_transforms) : 0;
  auto global_transforms__ = global_transforms ? _fbb.CreateVectorOfStructs<Transform>(*global_transforms) : 0;
  return CreateMeshes(
      _fbb,
      coordinates,
      meshes_items__,
      samples__,
      representations__,
      materials__,
      circle_extrusions__,
      shells__,
      local_transforms__,
      global_transforms__);
}

struct Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AttributeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *data() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.VerifyVectorOfStrings(data()) &&
           verifier.EndTable();
  }
};

struct AttributeBuilder {
  typedef Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> data) {
    fbb_.AddOffset(Attribute::VT_DATA, data);
  }
  explicit AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Attribute>(end);
    fbb_.Required(o, Attribute::VT_DATA);
    return o;
  }
};

inline ::flatbuffers::Offset<Attribute> CreateAttribute(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> data = 0) {
  AttributeBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Attribute> CreateAttributeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*data) : 0;
  return CreateAttribute(
      _fbb,
      data__);
}

struct Relation FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RelationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *data() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.VerifyVectorOfStrings(data()) &&
           verifier.EndTable();
  }
};

struct RelationBuilder {
  typedef Relation Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> data) {
    fbb_.AddOffset(Relation::VT_DATA, data);
  }
  explicit RelationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Relation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Relation>(end);
    fbb_.Required(o, Relation::VT_DATA);
    return o;
  }
};

inline ::flatbuffers::Offset<Relation> CreateRelation(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> data = 0) {
  RelationBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Relation> CreateRelationDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*data) : 0;
  return CreateRelation(
      _fbb,
      data__);
}

struct SpatialStructure FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SpatialStructureBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LOCAL_ID = 4,
    VT_CATEGORY = 6,
    VT_CHILDREN = 8
  };
  ::flatbuffers::Optional<uint32_t> local_id() const {
    return GetOptional<uint32_t, uint32_t>(VT_LOCAL_ID);
  }
  const ::flatbuffers::String *category() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CATEGORY);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<SpatialStructure>> *children() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<SpatialStructure>> *>(VT_CHILDREN);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_LOCAL_ID, 4) &&
           VerifyOffset(verifier, VT_CATEGORY) &&
           verifier.VerifyString(category()) &&
           VerifyOffset(verifier, VT_CHILDREN) &&
           verifier.VerifyVector(children()) &&
           verifier.VerifyVectorOfTables(children()) &&
           verifier.EndTable();
  }
};

struct SpatialStructureBuilder {
  typedef SpatialStructure Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_local_id(uint32_t local_id) {
    fbb_.AddElement<uint32_t>(SpatialStructure::VT_LOCAL_ID, local_id);
  }
  void add_category(::flatbuffers::Offset<::flatbuffers::String> category) {
    fbb_.AddOffset(SpatialStructure::VT_CATEGORY, category);
  }
  void add_children(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<SpatialStructure>>> children) {
    fbb_.AddOffset(SpatialStructure::VT_CHILDREN, children);
  }
  explicit SpatialStructureBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SpatialStructure> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SpatialStructure>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SpatialStructure> CreateSpatialStructure(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Optional<uint32_t> local_id = ::flatbuffers::nullopt,
    ::flatbuffers::Offset<::flatbuffers::String> category = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<SpatialStructure>>> children = 0) {
  SpatialStructureBuilder builder_(_fbb);
  builder_.add_children(children);
  builder_.add_category(category);
  if(local_id) { builder_.add_local_id(*local_id); }
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SpatialStructure> CreateSpatialStructureDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Optional<uint32_t> local_id = ::flatbuffers::nullopt,
    const char *category = nullptr,
    const std::vector<::flatbuffers::Offset<SpatialStructure>> *children = nullptr) {
  auto category__ = category ? _fbb.CreateString(category) : 0;
  auto children__ = children ? _fbb.CreateVector<::flatbuffers::Offset<SpatialStructure>>(*children) : 0;
  return CreateSpatialStructure(
      _fbb,
      local_id,
      category__,
      children__);
}

struct Alignment FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AlignmentBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ABSOLUTE = 4
  };
  const ::flatbuffers::Vector<uint32_t> *absolute() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_ABSOLUTE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ABSOLUTE) &&
           verifier.VerifyVector(absolute()) &&
           verifier.EndTable();
  }
};

struct AlignmentBuilder {
  typedef Alignment Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_absolute(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> absolute) {
    fbb_.AddOffset(Alignment::VT_ABSOLUTE, absolute);
  }
  explicit AlignmentBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Alignment> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Alignment>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Alignment> CreateAlignment(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> absolute = 0) {
  AlignmentBuilder builder_(_fbb);
  builder_.add_absolute(absolute);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Alignment> CreateAlignmentDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint32_t> *absolute = nullptr) {
  auto absolute__ = absolute ? _fbb.CreateVector<uint32_t>(*absolute) : 0;
  return CreateAlignment(
      _fbb,
      absolute__);
}

struct GeometryLines FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GeometryLinesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POINTS = 4
  };
  const ::flatbuffers::Vector<const FloatVector *> *points() const {
    return GetPointer<const ::flatbuffers::Vector<const FloatVector *> *>(VT_POINTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_POINTS) &&
           verifier.VerifyVector(points()) &&
           verifier.EndTable();
  }
};

struct GeometryLinesBuilder {
  typedef GeometryLines Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_points(::flatbuffers::Offset<::flatbuffers::Vector<const FloatVector *>> points) {
    fbb_.AddOffset(GeometryLines::VT_POINTS, points);
  }
  explicit GeometryLinesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GeometryLines> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GeometryLines>(end);
    fbb_.Required(o, GeometryLines::VT_POINTS);
    return o;
  }
};

inline ::flatbuffers::Offset<GeometryLines> CreateGeometryLines(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<const FloatVector *>> points = 0) {
  GeometryLinesBuilder builder_(_fbb);
  builder_.add_points(points);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<GeometryLines> CreateGeometryLinesDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<FloatVector> *points = nullptr) {
  auto points__ = points ? _fbb.CreateVectorOfStructs<FloatVector>(*points) : 0;
  return CreateGeometryLines(
      _fbb,
      points__);
}

struct Geometries FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GeometriesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SAMPLES = 4,
    VT_TRANSFORMS = 6,
    VT_LINES = 8
  };
  const ::flatbuffers::Vector<const GeometrySample *> *samples() const {
    return GetPointer<const ::flatbuffers::Vector<const GeometrySample *> *>(VT_SAMPLES);
  }
  const ::flatbuffers::Vector<const Transform *> *transforms() const {
    return GetPointer<const ::flatbuffers::Vector<const Transform *> *>(VT_TRANSFORMS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<GeometryLines>> *lines() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<GeometryLines>> *>(VT_LINES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_SAMPLES) &&
           verifier.VerifyVector(samples()) &&
           VerifyOffsetRequired(verifier, VT_TRANSFORMS) &&
           verifier.VerifyVector(transforms()) &&
           VerifyOffsetRequired(verifier, VT_LINES) &&
           verifier.VerifyVector(lines()) &&
           verifier.VerifyVectorOfTables(lines()) &&
           verifier.EndTable();
  }
};

struct GeometriesBuilder {
  typedef Geometries Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_samples(::flatbuffers::Offset<::flatbuffers::Vector<const GeometrySample *>> samples) {
    fbb_.AddOffset(Geometries::VT_SAMPLES, samples);
  }
  void add_transforms(::flatbuffers::Offset<::flatbuffers::Vector<const Transform *>> transforms) {
    fbb_.AddOffset(Geometries::VT_TRANSFORMS, transforms);
  }
  void add_lines(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GeometryLines>>> lines) {
    fbb_.AddOffset(Geometries::VT_LINES, lines);
  }
  explicit GeometriesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Geometries> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Geometries>(end);
    fbb_.Required(o, Geometries::VT_SAMPLES);
    fbb_.Required(o, Geometries::VT_TRANSFORMS);
    fbb_.Required(o, Geometries::VT_LINES);
    return o;
  }
};

inline ::flatbuffers::Offset<Geometries> CreateGeometries(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<const GeometrySample *>> samples = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const Transform *>> transforms = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GeometryLines>>> lines = 0) {
  GeometriesBuilder builder_(_fbb);
  builder_.add_lines(lines);
  builder_.add_transforms(transforms);
  builder_.add_samples(samples);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Geometries> CreateGeometriesDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<GeometrySample> *samples = nullptr,
    const std::vector<Transform> *transforms = nullptr,
    const std::vector<::flatbuffers::Offset<GeometryLines>> *lines = nullptr) {
  auto samples__ = samples ? _fbb.CreateVectorOfStructs<GeometrySample>(*samples) : 0;
  auto transforms__ = transforms ? _fbb.CreateVectorOfStructs<Transform>(*transforms) : 0;
  auto lines__ = lines ? _fbb.CreateVector<::flatbuffers::Offset<GeometryLines>>(*lines) : 0;
  return CreateGeometries(
      _fbb,
      samples__,
      transforms__,
      lines__);
}

struct Model FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ModelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_METADATA = 4,
    VT_GUIDS = 6,
    VT_GUIDS_ITEMS = 8,
    VT_MAX_LOCAL_ID = 10,
    VT_LOCAL_IDS = 12,
    VT_CATEGORIES = 14,
    VT_MESHES = 16,
    VT_ATTRIBUTES = 18,
    VT_RELATIONS = 20,
    VT_RELATIONS_ITEMS = 22,
    VT_GUID = 24,
    VT_SPATIAL_STRUCTURE = 26,
    VT_ALIGNMENTS = 28,
    VT_GEOMETRIES = 30
  };
  const ::flatbuffers::String *metadata() const {
    return GetPointer<const ::flatbuffers::String *>(VT_METADATA);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *guids() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_GUIDS);
  }
  const ::flatbuffers::Vector<uint32_t> *guids_items() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_GUIDS_ITEMS);
  }
  uint32_t max_local_id() const {
    return GetField<uint32_t>(VT_MAX_LOCAL_ID, 0);
  }
  const ::flatbuffers::Vector<uint32_t> *local_ids() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_LOCAL_IDS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *categories() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_CATEGORIES);
  }
  const Meshes *meshes() const {
    return GetPointer<const Meshes *>(VT_MESHES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Attribute>> *attributes() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Attribute>> *>(VT_ATTRIBUTES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Relation>> *relations() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Relation>> *>(VT_RELATIONS);
  }
  const ::flatbuffers::Vector<int32_t> *relations_items() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_RELATIONS_ITEMS);
  }
  const ::flatbuffers::String *guid() const {
    return GetPointer<const ::flatbuffers::String *>(VT_GUID);
  }
  const SpatialStructure *spatial_structure() const {
    return GetPointer<const SpatialStructure *>(VT_SPATIAL_STRUCTURE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Alignment>> *alignments() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Alignment>> *>(VT_ALIGNMENTS);
  }
  const Geometries *geometries() const {
    return GetPointer<const Geometries *>(VT_GEOMETRIES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_METADATA) &&
           verifier.VerifyString(metadata()) &&
           VerifyOffsetRequired(verifier, VT_GUIDS) &&
           verifier.VerifyVector(guids()) &&
           verifier.VerifyVectorOfStrings(guids()) &&
           VerifyOffsetRequired(verifier, VT_GUIDS_ITEMS) &&
           verifier.VerifyVector(guids_items()) &&
           VerifyField<uint32_t>(verifier, VT_MAX_LOCAL_ID, 4) &&
           VerifyOffsetRequired(verifier, VT_LOCAL_IDS) &&
           verifier.VerifyVector(local_ids()) &&
           VerifyOffsetRequired(verifier, VT_CATEGORIES) &&
           verifier.VerifyVector(categories()) &&
           verifier.VerifyVectorOfStrings(categories()) &&
           VerifyOffsetRequired(verifier, VT_MESHES) &&
           verifier.VerifyTable(meshes()) &&
           VerifyOffset(verifier, VT_ATTRIBUTES) &&
           verifier.VerifyVector(attributes()) &&
           verifier.VerifyVectorOfTables(attributes()) &&
           VerifyOffset(verifier, VT_RELATIONS) &&
           verifier.VerifyVector(relations()) &&
           verifier.VerifyVectorOfTables(relations()) &&
           VerifyOffset(verifier, VT_RELATIONS_ITEMS) &&
           verifier.VerifyVector(relations_items()) &&
           VerifyOffsetRequired(verifier, VT_GUID) &&
           verifier.VerifyString(guid()) &&
           VerifyOffset(verifier, VT_SPATIAL_STRUCTURE) &&
           verifier.VerifyTable(spatial_structure()) &&
           VerifyOffset(verifier, VT_ALIGNMENTS) &&
           verifier.VerifyVector(alignments()) &&
           verifier.VerifyVectorOfTables(alignments()) &&
           VerifyOffset(verifier, VT_GEOMETRIES) &&
           verifier.VerifyTable(geometries()) &&
           verifier.EndTable();
  }
};

struct ModelBuilder {
  typedef Model Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_metadata(::flatbuffers::Offset<::flatbuffers::String> metadata) {
    fbb_.AddOffset(Model::VT_METADATA, metadata);
  }
  void add_guids(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> guids) {
    fbb_.AddOffset(Model::VT_GUIDS, guids);
  }
  void add_guids_items(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> guids_items) {
    fbb_.AddOffset(Model::VT_GUIDS_ITEMS, guids_items);
  }
  void add_max_local_id(uint32_t max_local_id) {
    fbb_.AddElement<uint32_t>(Model::VT_MAX_LOCAL_ID, max_local_id, 0);
  }
  void add_local_ids(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> local_ids) {
    fbb_.AddOffset(Model::VT_LOCAL_IDS, local_ids);
  }
  void add_categories(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> categories) {
    fbb_.AddOffset(Model::VT_CATEGORIES, categories);
  }
  void add_meshes(::flatbuffers::Offset<Meshes> meshes) {
    fbb_.AddOffset(Model::VT_MESHES, meshes);
  }
  void add_attributes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Attribute>>> attributes) {
    fbb_.AddOffset(Model::VT_ATTRIBUTES, attributes);
  }
  void add_relations(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Relation>>> relations) {
    fbb_.AddOffset(Model::VT_RELATIONS, relations);
  }
  void add_relations_items(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> relations_items) {
    fbb_.AddOffset(Model::VT_RELATIONS_ITEMS, relations_items);
  }
  void add_guid(::flatbuffers::Offset<::flatbuffers::String> guid) {
    fbb_.AddOffset(Model::VT_GUID, guid);
  }
  void add_spatial_structure(::flatbuffers::Offset<SpatialStructure> spatial_structure) {
    fbb_.AddOffset(Model::VT_SPATIAL_STRUCTURE, spatial_structure);
  }
  void add_alignments(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Alignment>>> alignments) {
    fbb_.AddOffset(Model::VT_ALIGNMENTS, alignments);
  }
  void add_geometries(::flatbuffers::Offset<Geometries> geometries) {
    fbb_.AddOffset(Model::VT_GEOMETRIES, geometries);
  }
  explicit ModelBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Model> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Model>(end);
    fbb_.Required(o, Model::VT_GUIDS);
    fbb_.Required(o, Model::VT_GUIDS_ITEMS);
    fbb_.Required(o, Model::VT_LOCAL_IDS);
    fbb_.Required(o, Model::VT_CATEGORIES);
    fbb_.Required(o, Model::VT_MESHES);
    fbb_.Required(o, Model::VT_GUID);
    return o;
  }
};

inline ::flatbuffers::Offset<Model> CreateModel(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> metadata = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> guids = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> guids_items = 0,
    uint32_t max_local_id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> local_ids = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> categories = 0,
    ::flatbuffers::Offset<Meshes> meshes = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Attribute>>> attributes = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Relation>>> relations = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> relations_items = 0,
    ::flatbuffers::Offset<::flatbuffers::String> guid = 0,
    ::flatbuffers::Offset<SpatialStructure> spatial_structure = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Alignment>>> alignments = 0,
    ::flatbuffers::Offset<Geometries> geometries = 0) {
  ModelBuilder builder_(_fbb);
  builder_.add_geometries(geometries);
  builder_.add_alignments(alignments);
  builder_.add_spatial_structure(spatial_structure);
  builder_.add_guid(guid);
  builder_.add_relations_items(relations_items);
  builder_.add_relations(relations);
  builder_.add_attributes(attributes);
  builder_.add_meshes(meshes);
  builder_.add_categories(categories);
  builder_.add_local_ids(local_ids);
  builder_.add_max_local_id(max_local_id);
  builder_.add_guids_items(guids_items);
  builder_.add_guids(guids);
  builder_.add_metadata(metadata);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Model> CreateModelDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *metadata = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *guids = nullptr,
    const std::vector<uint32_t> *guids_items = nullptr,
    uint32_t max_local_id = 0,
    const std::vector<uint32_t> *local_ids = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *categories = nullptr,
    ::flatbuffers::Offset<Meshes> meshes = 0,
    const std::vector<::flatbuffers::Offset<Attribute>> *attributes = nullptr,
    const std::vector<::flatbuffers::Offset<Relation>> *relations = nullptr,
    const std::vector<int32_t> *relations_items = nullptr,
    const char *guid = nullptr,
    ::flatbuffers::Offset<SpatialStructure> spatial_structure = 0,
    const std::vector<::flatbuffers::Offset<Alignment>> *alignments = nullptr,
    ::flatbuffers::Offset<Geometries> geometries = 0) {
  auto metadata__ = metadata ? _fbb.CreateString(metadata) : 0;
  auto guids__ = guids ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*guids) : 0;
  auto guids_items__ = guids_items ? _fbb.CreateVector<uint32_t>(*guids_items) : 0;
  auto local_ids__ = local_ids ? _fbb.CreateVector<uint32_t>(*local_ids) : 0;
  auto categories__ = categories ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*categories) : 0;
  auto attributes__ = attributes ? _fbb.CreateVector<::flatbuffers::Offset<Attribute>>(*attributes) : 0;
  auto relations__ = relations ? _fbb.CreateVector<::flatbuffers::Offset<Relation>>(*relations) : 0;
  auto relations_items__ = relations_items ? _fbb.CreateVector<int32_t>(*relations_items) : 0;
  auto guid__ = guid ? _fbb.CreateString(guid) : 0;
  auto alignments__ = alignments ? _fbb.CreateVector<::flatbuffers::Offset<Alignment>>(*alignments) : 0;
  return CreateModel(
      _fbb,
      metadata__,
      guids__,
      guids_items__,
      max_local_id,
      local_ids__,
      categories__,
      meshes,
      attributes__,
      relations__,
      relations_items__,
      guid__,
      spatial_structure,
      alignments__,
      geometries);
}

inline const Model *GetModel(const void *buf) {
  return ::flatbuffers::GetRoot<Model>(buf);
}

inline const Model *GetSizePrefixedModel(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<Model>(buf);
}

inline const char *ModelIdentifier() {
  return "0001";
}

inline bool ModelBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, ModelIdentifier());
}

inline bool SizePrefixedModelBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, ModelIdentifier(), true);
}

inline bool VerifyModelBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Model>(ModelIdentifier());
}

inline bool VerifySizePrefixedModelBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Model>(ModelIdentifier());
}

inline void FinishModelBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Model> root) {
  fbb.Finish(root, ModelIdentifier());
}

inline void FinishSizePrefixedModelBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Model> root) {
  fbb.FinishSizePrefixed(root, ModelIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_INDEX_H_
